#include <iostream>
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include <cstdlib>
#include <math.h>
#include <iomanip>
#include "map.h"
#include <regex>

std::string cppFile = "code.cpp";
std::string codeFile;
std::vector<std::string> codeData;
std::vector<std::string> cppData;

std::vector<std::string> special = {"for", "if", "while", "switch", "catch", "elif", "catch", "foreach", "readLine", "loop", "loopStep"};
std::vector<char> semiColumnImune = {'>', '{', '(', ':', ';', ',', '}', ' '};
std::vector<char> separators = {' ', '.', '<', '>', '(', ')', ';', '{', '}', '"', ':', '*', '&'};
std::vector<std::string> globalExpresions = {"", ""};

float becVersion = 2.0;
int loadData();
int compileFile();
int findMainPos();
void executeLines();
void loadExternFileToVector(std::vector<std::string>* externData, std::string fileName);
void createCppFile();
void importTypedefs();
void importIncludes();
void importFunctions();
void importBecHeaders();
bool isValidDataType(const std::string& input);

std::string trimTrailingSpaces(const std::string& line);
std::string parser(std::string line);
std::string addSemiColumn(std::string line);
std::string addBrackets(std::string line);
std::vector<char*> arguments;

int main(int argc, char* argv[]) {
    if (argc == 2) {
        if (std::string(argv[1]) == "version") {
            std::cout << "Bec version " << std::fixed << std::setprecision(1) << becVersion << std::endl;
            return 0;
        }
        if (std::string(argv[1]) == "info") {
            std::cout << "Bec is simple programing language created on top of c++." <<std::endl;
            std::cout << "The main goal of bec is to simplify c++ syntax but preserve performance," <<std::endl;
            std::cout << "which is achieved by translating bec directly to c++ and the resulting c++ file is translated using g++." << std::endl;
            std::cout << "Bec is just a small project that I made because I had nothing to do during the holidays, but if anyone can use it, I will be very happy" << std::endl;
            return 0;
        }
    }
    else if (argc > 2) {
        codeFile = argv[3];
        for (int i = 1; i < argc; i++) {
            arguments.push_back(argv[i]);
        }
    } else {
        std::cout << "Not enought arguments given" << std::endl;
        return 0;
    }
    
    if (loadData() == 0) {
        std::cout << "Could not load file data" << std::endl;
        return 0;
    }
    loadVocabulary();
    loadMacros();
    loadIncludes();

    executeLines();
    createCppFile();

    if (compileFile() != 0) {
        return 0;
    }
   return 0;
}

void executeLines() {
    cppData.push_back("// .-----------------------------------------------------------------------------------.");
    cppData.push_back("// |######                                                                             |");
    cppData.push_back("// |#     # ######  ####              #####  ###### ##### ##### ###### #####      #### |");
    cppData.push_back("// |#     # #      #    #             #    # #        #     #   #      #    #    #    #|");
    cppData.push_back("// |######  #####  #         #####    #####  #####    #     #   #####  #    #    #     |");
    cppData.push_back("// |#     # #      #                  #    # #        #     #   #      #####     #     |");
    cppData.push_back("// |#     # #      #    #             #    # #        #     #   #      #   #     #    #|");
    cppData.push_back("// |######  ######  ####              #####  ######   #     #   ###### #    #     #### |");
    cppData.push_back("// '-----------------------------------------------------------------------------------'");
    cppData.push_back("//--------------------------------------------------------------------------------------");


    //import default includes
    importIncludes();
    //import bec specific macros for simplified syntax
    importTypedefs();
    for (int y = 0; y < codeData.size(); y++) {
        cppData.push_back(parser(codeData[y]));
    }
    //import other bec files
    importBecHeaders();
    //import functions on top of main
    importFunctions();
    cppData.push_back("//This code was generated by BEC compiler created by Václav Harang");
}


int findMainPos() {
    int mainPos = 0;
    for (int i = 0; i < cppData.size(); i++) {
        if (cppData[i] == "int main(int argc, char* argv[]) {") {
            mainPos = i;
            break;
        }
    }
    mainPos--;
    return mainPos;
}

void loadExternFileToVector(std::vector<std::string>* externData, std::string fileName) {
    std::ifstream file(fileName);
    if (!file.is_open()) {
        std::cerr << "Chyba při otevírání souboru: " << fileName << std::endl;
    }
    std::string line;
    while (std::getline(file, line)) {
        (*externData).push_back(line);
    }
    file.close();
}

void importBecHeaders() {
    for (int y = 0; y < cppData.size(); y++) {
        std::string line = cppData[y];
        if (!(line.find("#include") == 0)) {
            continue;
        }
        std::string restOfLine = line.substr(8);
        std::size_t firstSpace = restOfLine.find_first_not_of(" \t");
        std::size_t secondSpace = restOfLine.find_first_of(" \t", firstSpace);
        if (firstSpace == std::string::npos) {
            continue;
        }
        std::string fileName = restOfLine.substr(firstSpace, secondSpace - firstSpace);
        if (!fileName.empty() && fileName.front() == '\"' && fileName.back() == '\"') {
            fileName = fileName.substr(1, fileName.size() - 2);
        }
        bool dotFound = false;
        std::string suffix = "";
        for (int i = 0; i < fileName.length(); i++) {
            if (fileName[i] == '.') dotFound = true;
            if (dotFound) suffix += fileName[i];
        } 
        if (suffix != ".bec") {
            continue;
        }
        cppData.erase(cppData.begin() + y);
        //find main
        int mainPos = findMainPos();
        //importing file with suffix .bec, add it to cpp file trough parser
        //first we need to open the file
        std::vector<std::string> externData;
        loadExternFileToVector(&externData, fileName);
        
        //file data loaded to exterData vector, now insert data to cppFile trough parser
        for (int j = 0; j < externData.size(); j++) {
            cppData.insert(cppData.begin() + mainPos, parser(externData[j]));
            mainPos++;
        }
        std::cout << fileName << " data inserted" << std::endl;
        y = 0; //do it again because all content in code has beed moved
    }
}

void importFunctions() {
    //find main
    int mainPos = findMainPos();
    //main pos found, now add functions on top of main
    cppData.insert(cppData.begin() + mainPos, "//-----------------------------------------------------------------------------------------------------------");
    for (int i = 1; i < codeData.size(); i++) {
        bool isDef = false;
        std::string first = codeData[i].substr(0, codeData[i].find(" "));

        if (first == "def") isDef = true;
        else if (isValidDataType(first) && codeData[i].back() == '{') isDef = true;
        if (first == "assigned") isDef = false;

        if (isDef) {
            std::string line = codeData[i];
            if (line.back() == '{') line.pop_back();
            cppData.insert(cppData.begin() + mainPos, parser(line));
        }
    }
    cppData.insert(cppData.begin() + mainPos, "//----------------------------------------Functions declarations--------------------------------------------");
}

bool isValidDataType(const std::string& input) {
    std::regex typePattern(R"(bool|char|short|int|num|word|long|unsigned|float|double|long\sdouble|string|vector|list|map|std::string|std::vector|std::list|std::map|uint8_t|uint16_t|uint32_t|uint64_t|int8_t|int16_t|int32_t|int64_t)");
    return std::regex_match(input, typePattern);
}

void importIncludes() {
    cppData.push_back("");
    cppData.push_back("//--------------------------------------------Bec default includes----------------------------------------");
    for (int y = 0; y < includes.size(); y++) {
        cppData.push_back(includes[y]);
    }
    cppData.push_back("//------------------------------------------------------------------------------------------------------");
    cppData.push_back("");
}

void importTypedefs() {
    cppData.push_back("");
    cppData.push_back("//--------------------------------------------Bec default macros----------------------------------------");
    for (int y = 0; y < macros.size(); y++) {
        cppData.push_back(macros[y]);
    }
    cppData.push_back("//------------------------------------------------------------------------------------------------------");
    cppData.push_back("");
}

std::string parser(std::string line) {
    line = trimTrailingSpaces(line);
    std::string cppLine = "";
    std::vector < std::string > expresions; 
    std::vector<char> separatorsInOrder;
    std::vector<bool> finalOrder; //1 is for expresion, 0 is for separator

    std::string current = ""; //current word we are checking

    bool inQuotes = false;
    bool inSingleQuotes = false;

    for (int i = 0; i < line.length(); i++) { 

        char c = line[i];
        if (c == '\"') {
            inQuotes = !inQuotes; // Toggle state
            current += c;
            continue;
        } else if (c == '\'') {
            inSingleQuotes = !inSingleQuotes; // Toggle state
            current += c;
            continue;
        }

        bool isSeparator = false; 
        //check if( current character == not a separator; 
        if (!inQuotes && !inSingleQuotes) {
            for (int j = 0; j < separators.size(); j++) { 
                if (line[i] == separators[j]) { 
                    isSeparator = true; 
                    //create vector with separators in order like in given line, so it will be easier to create right cpp line
                    separatorsInOrder.push_back(separators[j]);
                    finalOrder.push_back(0);
                    break;
                } 
            } 
        }

        if (isSeparator) { 
            expresions.push_back(current); 
            finalOrder.push_back(1);
            //WE DO NOT WANT TO CHANGE INCLUDES
            if (expresions[0] == "import") {
                std::string importLine = line;
                importLine.replace(0, 6, "#include");
                return importLine;
            }
            current = ""; 
            continue; 
        } else { 
            current += line[i]; 
        } 
    } 
    if (current.length() > 0) { 
        expresions.push_back(current);
    }

    //putting first two values to global, but checking empty values
    int counter = 0;
    for (int i = 0; i < expresions.size(); i++) {
        if (counter > 1) break;
        if (expresions[i].find_first_not_of(' ') != std::string::npos && expresions[i].length() > 0) {
            globalExpresions[counter] = expresions[i];
            counter++;
        }
    }
    //changing expresions with coresponding c++ expresions, but check if they are not in "", theese values cannot change
    for (int y = 0; y < expresions.size(); y++) {
        if (expresions[y].front() != '\"' && expresions[y].front() != '\'') {
            if (vocabulary.find(expresions[y]) != vocabulary.end()) {
                expresions[y] = vocabulary[expresions[y]];
            }
        }
    }

    //create new cpp line that will be returned
    for (const auto& b : finalOrder) {
        if (!b) {
            //if 1, add expresion
            cppLine += expresions[0];
            expresions.erase(expresions.begin());
        } else {
            //if 0, add separator
            cppLine += separatorsInOrder[0];
            separatorsInOrder.erase(separatorsInOrder.begin());
        }
    }

    if (expresions.size() > 0) {
        cppLine += expresions[0];
    }

    if (cppLine.length() > 0 && cppLine.find_first_not_of(' ') != std::string::npos) {
        return addSemiColumn(cppLine);
    } else {
        return cppLine;
    }
}

std::string trimTrailingSpaces(const std::string& line) {
    std::string trimmedLine = line;
    auto endPos = std::find_if(trimmedLine.rbegin(), trimmedLine.rend(), [](char ch) {
        return !std::isspace(static_cast<unsigned char>(ch));
    }).base();
    trimmedLine.erase(endPos, trimmedLine.end());
    return trimmedLine;
}

std::string addSemiColumn(std::string line) {
    char last = line[line.length()-1];
    std::string newLine;
    bool isImune = false;
    for (int i = 0; i < semiColumnImune.size(); i++) {
        if (last == semiColumnImune[i]) {
            isImune = true;
        }
    }

    if (!isImune) {
        newLine = line + ';';
        return newLine;
    } else {
        return addBrackets(line);
    }
}

std::string addBrackets(std::string line) {
    std::string newLine = line;
    if (globalExpresions.size() > 1) {
        for (int i = 0; i < 2; i++) {
            if (std::find(special.begin(), special.end(), globalExpresions[i]) != special.end()) {
                if (globalExpresions[i] != "readLine") {
                    newLine.insert(newLine.length()-1, 1, ')');
                } else {
                    newLine += ')';
                }
                return newLine;
            }
        }
    } else {
        return line;
    }
    return line;
}

void createCppFile() {
    std::ofstream outFile(cppFile);
    
    if (!outFile) {
        std::cerr << "Chyba při otevírání souboru k zápisu: " << cppFile << std::endl;
        return;
    }
    
    for (const auto& line : cppData) {
        outFile << line;
        outFile << std::endl;
    }
    
    outFile.close();
}

int loadData() { //loading data from bec code file to codeFile vector<string> where each element is line of code
    std::ifstream file(codeFile);
    if (!file.is_open()) {
        std::cerr << "Chyba při otevírání souboru: " << codeFile << std::endl;
        return 0;
    }
    std::string line;
    while (std::getline(file, line)) {
       codeData.push_back(line);
    }
    file.close();
    return 1;
}

int compileFile() {
    bool removecpp = true;
    std::string commandString = "g++ ";
    for (int i = 0; i < arguments.size(); i++) {
        if (i != 2) {
            if (std::string(arguments[i]) != "showCpp") { //checking if user wants to see output of c++ file
                commandString += arguments[i];
                commandString += " ";
            } else {
                removecpp = false;
            }
        } else {
            commandString += cppFile;
            commandString += " ";
        }
    }

    if (removecpp) commandString += "&& del code.cpp";

    const char* command = commandString.c_str();
    int compilationResult = system(command);
    if (compilationResult == 0) {
        std::cout << "Code compiled succesfully" << std::endl;
    } else {
        std::cout << "Could not compile code" << std::endl;
    }
    return compilationResult;
}